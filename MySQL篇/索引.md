---
索引
---

# 索引

## 索引的物理结构

1. ### 数据页是怎么存储的？

    ![](..\imgs\数据页存储结构.png)
   1. 数据页都是放在磁盘文件中
   2. 数据页的两两相邻间采用双向链表连接
   3. 数据页就是一段数据，可能是二进制，或者是别的特殊格式，包含两个指针，一个指向上一个物理页，一个指向下一个物理页
   4. 数据行是根据主键大小由小到大进行排列的
   5. 每个数据页都有一个页目录，里面根据数据行主键存放了一个目录，同时数据行是被分散到不同槽位里去的
   
2. ### 仅有一个数据页如何寻找到数据？

   1. 根据主键进行查找的时候

      会先到数据页目录里根据主键进行二分查找，然后定位到具体哪个槽位，相应的读取那行数据即可

   2. 非主键查找的时候

      只能根据链表去遍历数据页的每一行数据

3. ### 多个数据页的情况下，如何进行查找？

   1. 根据主键进行查找的时候，根据二分查找法进行查找
   2. 不根据主键的时候，都是如上所示，根据链表进行遍历。从第一个数据页开始，从磁盘中读取到Buffer pool缓存中，如果没有则继续加载下一页。

4. ### 页分裂过程？
      ​	<img src="..\imgs\页分裂过程.png" style="zoom:80%;" />
![](..\imgs\页分裂过程.png)
   1. 页的结构
      - 页的最开始的一行是起始行，数据类型为2，即页中最小的一行，有指针指向下一行
      - 普通行的数据类型为0，每一行都有 数据类型、id、指针、数据值这四个东西，通过指针不断的指向下一行
      - 末尾行的类型为3
   2. 页分裂过程
      1. 索引运行基础： 后一个数据也的id值都大于前一个数据页的主键值
      2. 当插入一条数据时，如上图所示，新建的一个数据页的id值是小于上一页的最大id值的，所以此时要进行页分裂
      3. 即在插入新的数据页如果无法保证顺序，则进行页分裂。
      4. 将上一个数据页id的大值，挪到后一个数据页中，将较小的id值挪到前一页中

5. ### 基于主键索引的查询设计
      ​	<img src="..\imgs\索引页建立过程.png" style="zoom:80%;" />
   ![](..\imgs\索引页建立过程.png)

   - 每个数据页都有页目录，里面记录了主键和行的信息
   - 可根据二分查找法来寻找主键的位置，定位到具体的数据页，然后再在数据页中二分查找具体行信息
   - 索引页也是放在数据页里的
   - 当数据页过多的时候，会抽象一层数据页，保留了最小页的最小索引值和最大页的最小索引值
   - 如果索引页的下层索引由于页分页依然太多了怎么办？向上再抽象出一层索引页
   - 在上述的索引页抽离过程中，即形成了一颗B+树

## 索引的维护

1. ### 插入/更新数据的时候，如何维护聚簇索引？

   1. 索引页与数据页之间是通过指针相互连接起来的
   2. 索引页之间也是通过指针连接起来的，同一层级索引页之间组成双向链表
   3. 由于索引页是存储在数据页之中，故最底层索引页实际上是通过双向链表进行连接起来的
   4. 叶子结点存放的为数据页本身
   5. 由于这种B+树索引数据结构里，叶子结点就是数据页本身，那么此时我们就可以称这颗B+树索引为聚簇索引
   6. 如果你一直向表中insert数据，就是直接将数据页放在聚簇索引里
   7. 如果数据页进行了页分裂，此时会调整各个数据行的数据，保证主键是必须有序的
   8. 同时在页分裂时，会维护上层索引的数据结构，在上层索引中维护你的数据条目，不同数据页和最小主键的值
   9. 如若你数据页越来越多，一个索引页放不下，此时会拉出新的数据页，同时再搞一个上层索引页，存放页号和最小主键值

2. ### 针对非主键索引建立的二级索引是如何运作的？

   1. 如果你建立了一个二级索引，则会根据这个二级索引再建一颗索引树
      - 如根据name建立一个索引，B+树的叶子结点也是存放了数据页，但是这个数据页里仅包含了主键字段+name值
   2. 排序规则和之前使用主键索引的排序规则是一致的，先按被索引字段（name），如若相同则按主键进行排序
   3. 向上抽离索引页的时候，抽离的为最小name值字段
   4. 如select * from users where name='zhangsan'
      - 会先根据name字段的值，在name的B+树中找到对应的主键值
      - 然后根据主键值，再到聚簇索引的根节点开始，一路通过二分查找法找到叶子结点的数据页
      - 找到数据页之后，再通过二分查找法，找到对应的数据行
   5. 联合索引雷同，只过不叶子结点存放的为如 name+age和id的值,然后默认是按照name排序，name相同则使用age，都相同再根据主键进行排序

3. ### 数据insert的时候，是如何维护好不同索引之间的B+树？

   1. 首先有一层数据页，它是聚簇索引的一部分，也是叶子结点，默认有一个基于主键的页目录，第一个页为根页
   2. 然后页里数据越来越多，即会引发页分裂，将较大的数据拷贝到后一个数据页，将较小的数据拷贝到前一个数据页之中，重新维护主键的顺序
   3. 根页然后会升级为索引页，放的是页分裂后两个数据页号和他们各自的最小主键值
   4. 继续插入数据，当索引页的空间已经无法存放页号和最小索引页的值的时候，即会再向上抽离出根页，就形成了三层索引
   5. 当插入一条数据至二级索引（如name），会先根据name定位到插入哪一个数据页，如果name一致，但指向的页号不同，则需要根据主键去判断一下，较大的主键会到下一行

4. ### 总结

   1. 聚簇索引的叶子结点都是数据页，里面存放的是一行行数据
   2. 数据页之间是通过双向链表进行连接的，而且是有序的
   3. 如果建立二级索引，则是重新建立一颗B+树，存放的为被索引字段+主键值，根据被索引字段进行排序
   4. 二级索引假如查找非索引字段，需要回表查询数据
   5. 优点： 
      - 查询的时候，不需要全表扫描，提升性能
   6. 缺点：
      - 每颗B+树都要占用空间
      - 增删改都得额外维护二级索引，和索引的有序性
      - 一直insert会导致页分裂频繁

## 索引的匹配原则

1. ### 联合索引查询以及匹配等值原则

   1. 目的:

      1. 尽可能让索引少一些，提升增删改索引的性能

         ![](..\imgs\联合索引结构.png)

      2. 如使用class+name+subject来做索引，有一个where条件 where class_name = '1班' and student_name='张小强' and subject_name='数学'，这种即是等值查询，查询的数据和索引一模一样，故能100%利用联合索引

2. 常见的索引使用规则

   1. 最左侧匹配原则
      - 如上述所使用的索引，可以不全部都等值匹配
      - 使用左前索引，如使用class_name='1班' and student_name='张小强' 也是可以的
   2. 最左前缀使用匹配规则，使用like语法
      - 仅能匹配左前，如class_name like '1%' 而不能使用 class_name like '%班'
   3. 范围查找规则，即
      - where class_name>'1班' and class_name<'5班'  是可以用到索引的
      - where class_name>'1班' and class_name<'5班' and student_name='张三'  此时student_name='张三'这个条件是无法使用到索引的
      - where class_name='1班' and  student_name='张三'  and subject_name>2 也是可以使用到索引的
   4. 总结
      - 都是只能用联合索引最左侧多个字段来等值查询+范围匹配的
      - 或基于最左前部分字段进行左前缀模糊匹配
      - 或基于左侧字段范围搜索

3. 排序的时候，如何才能使用到索引？

   1. filesort： 基于磁盘排序MySQL的专业术语，这个查询是比较慢的
   2. 如默认index（class_name，student_name，subject_name）一个联合索引，并按其进行排序，此时按order by class_name，student_name，subject_name 是不用进行排序的
   3. 在你SQL语句中，应该尽量按照索引字段去order by进行排序
   4. 但是有一个限定，即order by的时候，顺序得一致，如都是 desc或者都是 asc

4. 分组的时候,什么时候能用到索引？

   1. group by后的字段，最好也是按照联合索引的最左前字段开始

## 索引的设计

1. 回表查询性能的损害以及覆盖索引？

   - 如select * from users order by xx1,xx2,xx3  每条数据都回表，性能也是不高的
   - 查询的字段，可直接从联合索引中取出，不需要回表到聚簇索引，这种查询叫覆盖索引

2. 索引设计的考虑因素？

   1. 针对SQL里的where、order by 以及 group by条件去设计索引

   2. 字段基于问题。如只有0和1，由于基数比较低，所以这种字段不适合二分查找法。所以一般建议基数比较大的字段，才能发挥二分查找法的优势

   3. 尽量用字段类型类型比较小的列设计索引，如tinyint。

   4. 如my_index(name(20),age,course)，此时name类型为varchar（255）此时搜索时，会定位到前20个字符的前缀匹配的部分数据之后，再回到聚簇索引取出完整值进行对比即可

      但是如果你order by name，但索引树仅包含前20个字段，是没法用上这个索引的。group by也是同理

   5. 针对很长的字符串，可以设置前缀索引进行where查询

   6. 不要在查询语句中加函数、计算等

   7. 设计索引的数量别太多，两三个通用索引能覆盖全表查询的索引即可

   8. 建议主键都是自增的，勿用uuid之类的索引。uuid会导致频繁的页分裂

   9. 等值匹配字段优先于范围匹配，如index（sex , age)如果传入的值没有sex，则可以使用如下语法

      sex in (0,1) and age >18，即是可以使用到联合索引的

   10. 尽量使用一两个复杂的联合索引，抗下80%以上的查询，然后用两三个辅助索引，抗下剩余20%的非典型查询，保证99%的业务都能使用到索引

3. 索引如何设计？

   - 一般来讲，应当先设计，表结构、表字段必须先满足业务需求
   - 然后再写代码，根据你的代码如何查询表来设计里面的索引
   - 考虑设计几个索引，是不是联合索引，选择哪些字段？字段顺序如何排序？才能让查询语句都用上索引

