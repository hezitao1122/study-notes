# 事务

1. ### 存在的问题

   1. 多事务并发操作数据，会存在哪些问题？

      多事务更新的时候是基于内存去进行更新操作的，会产生以下几种问题：

      - 脏读
      - 脏写
      - 不可重复读
      - 幻读

   2. 什么是脏写？

      - 事务A和事务B共同更新缓存页的一条数据，A先把值更新为a，此时A尚未提交事务
      - 此时B把值更新为b
      - B更新完后提交事务，然后A把事务回滚了，值又成了null
      - 此场景下B的写入即为脏写，即写入未生效

   3. 什么是脏读？

      - 事务A更新了一行数据的值为a，此时尚未提交事务
      - 然后此时事务B去查询数据，并且拿到a这个值后一顿操作
      - 然后事务A将值回滚了，然后B蒙圈了
      - 此场景下，事务B读到了事务A尚未提交的数据，这种场景叫脏读

   4. 什么是不可重复读？

      - 事务A开启一个事务，查询数据值a，并对a进行操作
      - 此时，事务B马上开启，并且修改了a的值为b，并提交事务
      - 事务A再查询的时候，值变成了b
      - 这种情况下，一个事务之内，读取的值不一样的情况下，叫不可重复读
      - 是否需要不可重复读，则需要看你的业务场景

   5. 什么是幻读？

      - 事务A开启的时候，去查询一张表，里面有十条数据
      - 此时事务B插入一条数据，然后提交事务
      - 事务A再次查询的时候，数据变成了十一条
      - 这种情况叫幻读，每次查询的结果不一致

2. 事务的概念

   | 隔离级别             | 名称     | 存在问题               |
   | -------------------- | -------- | ---------------------- |
   | read uncommit (RU)   | 读未提交 | 脏读、不可重复读、幻读 |
   | read commit (RC)     | 读已提交 | 不可重复读、幻读       |
   | repeatable read (RR) | 可重复读 | 幻读                   |
   | serializable         | 串行化   |                        |

   1. MySQL默认隔离级别
      
      默认是RR，可重复读
      
      InnoDB的可重复读是可以避免幻读的
      
      修改隔离级别： SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL level;
      
      Spring中设置事务隔离级别： @Transactional（isolation=Isolation.Default)

3. MVCC机制:

   1. undo log版本日志链

      <img src="..\imgs\undo log日志链.png" style="zoom:100%;" />、

      - 如上图所示，事务A（id=50）插入了一条数据A，由于这条数据之前不存在，所以roll_pointer指向为null
      - 假如此时一个事务B（id=55）过来修改数据A为B，此时更新前会生成一个新的undo log日志，记录修改后的值和修改的事务id，然后讲roll_pointer指向修改前的那条undo log日志

   2. undo log日志链的ReadView机制

      1. 事务执行的时候会生成一个ReadView，里面包含四个东西

         - m_ids 记录此时事务开启的时候，尚未提交的事务的id
         - min_trx_id   m_ids中事务id的最小的值
         - max_trx_id m_ids中事务id的最大的值
         - creator_trx_id 开启这个ReadView的id

      2. ReadView实现步骤

         <img src="..\imgs\ReadView日志链应用.png" style="zoom:67%;" />

         - 事务A开启了一个ReadView，m_ids中包含了45、58、60三个id
         - 事务A第一次查询会进行判断，当前这行数据的trx_id是否小于ReadView中的min_trx_id，小于则代表这行数据早就被提交了
         - 接着，事务B将值修改为B，并将txr_id设置为自己的事务id，同时roll_pointer指向了修改之前的undo log日志，接着就提交了日志
         - 然后A再次查询此条数据，会发现txr_id已经被修改为59，这是大于ReadView里的min_txr_id（45）的，且小于ReadView中的max_trx_id（60）的
         - 然后查询txr_id=59是否存在ReadView中，在则不能查询
         - 顺着roll_pointer往下找，并对比txr_id与ReadView中的min_txr_id的值，小于则取此值
         - 通过这套ReadView+undo log日志链条机制，就可以保证事务A不会读取到并发执行事务B更新的值，只会读取到更早的值

   3. MVCC机制

      1. MVCC机制是什么？用途是什么？
         1. mult_version_concurrent_controller 多版本并发控制机制
         2. 用途： 专门控制多个事务并发运行的时候，互相之间的影响
         3. 特点： 基于特有的ReadView机制+undo log日志链，即可实现可重复读，并且不会产生幻读
         4. 主要解决的为一个事务读，其他事务写的数据可见性等问题

# 锁

1. ## 概述

   1. ### 什么是锁机制?

      依靠锁机制，可以让多个事务更新同一行数据的时候进行串行化操作，避免同时更新一行数据而产生冲突

   2. 怎么加锁？

      <img src="..\imgs\加锁步骤.png" style="zoom:67%;" />

      1. 更新一个事务的时候，首先会将数据从磁盘的数据页加载到缓存中
      2. 一个事务过来更新，首先会查看是否有其他人对其加锁，不存在其他锁关联的情况下，事务就会创建一个锁对象，里面包含了自己的trx_id和等待状态
      3. 创建完锁对象后，会在内存中将这行数据与锁对象进行关联
      4. 如果此时有另外一个事务B来更新这行数据，会先创建一个锁对象，然后去查看是否有其他事务关联了这行数据，如果有则将等待修改为true，然后再给这个锁关联上
      5. 事务A修改完数据后，释放锁，然后再去唤醒事务B，把所对象的等待改为false

2. 共享锁和独占锁

   1. 更新数据的时候，其他事务可读取此行数据吗？默认情况下是否需要加锁？
      - 不用
      - 更新的时候，另外有事务去读取这行数据，默认是开启MVCC模式的
      - 读取更新的数据的时候，会根据ReadView和undo log版本日志链中找一个能读取的版本
   2. 查询的时候，是否需要加锁？
      - 共享锁的语法： select * from table lock in share mode
      - 互斥锁的语法： select * from table for update
      - 共享锁和独占锁是互斥的，共享锁之间不互斥
      - 一般不会在数据层面做复杂的手动加锁操作，而会基于redis、zookeeper做分布式锁来控制业务系统的逻辑
   3. 哪些操作会导致表级锁？
      1. DDL语句会进行表锁，基于MySQL的元数据锁进行实现
      2. 且DDL语句的锁和增删改操作的锁是互斥的

3. MySQL是如何加表级锁？

   1. 语法：

      - 表级共享锁 ： lock tables my_table READ
      - 表级独占锁 ： lock tables my_table WRITER

   2. 一般情况下，没人用上述语法显示加锁

   3. 如果事务在表里进行增删改查，会对修改的行加独占锁，切在表级别加独占意向锁

   4. 事务在表里查询数据的时候，会在表级加一个意向共享锁

      |   锁类型   | 独占锁 | 意向独占锁 | 共享锁 | 意向共享锁 |
      | :--------: | :----: | :--------: | :----: | :--------: |
      |   独占锁   |   √    |     √      |   √    |     √      |
      | 意向独占锁 |   √    |     ×      |   √    |     ×      |
      |   共享锁   |   √    |     √      |   ×    |     ×      |
      | 意向共享锁 |   √    |     ×      |   ×    |     ×      |

      × - 代表不互斥

      √ - 代表互斥