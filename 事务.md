# 事务

1. ## 基本概念

   1. ### 存在的问题

      1. 多事务并发操作数据，会存在哪些问题？

         多事务更新的时候是基于内存去进行更新操作的，会产生以下几种问题：

         - 脏读
         - 脏写
         - 不可重复读
         - 幻读

      2. 什么是脏写？

         - 事务A和事务B共同更新缓存页的一条数据，A先把值更新为a，此时A尚未提交事务
         - 此时B把值更新为b
         - B更新完后提交事务，然后A把事务回滚了，值又成了null
         - 此场景下B的写入即为脏写，即写入未生效

      3. 什么是脏读？

         - 事务A更新了一行数据的值为a，此时尚未提交事务
         - 然后此时事务B去查询数据，并且拿到a这个值后一顿操作
         - 然后事务A将值回滚了，然后B蒙圈了
         - 此场景下，事务B读到了事务A尚未提交的数据，这种场景叫脏读

      4. 什么是不可重复读？

         - 事务A开启一个事务，查询数据值a，并对a进行操作
         - 此时，事务B马上开启，并且修改了a的值为b，并提交事务
         - 事务A再查询的时候，值变成了b
         - 这种情况下，一个事务之内，读取的值不一样的情况下，叫不可重复读
         - 是否需要不可重复读，则需要看你的业务场景

      5. 什么是幻读？

         - 事务A开启的时候，去查询一张表，里面有十条数据
         - 此时事务B插入一条数据，然后提交事务
         - 事务A再次查询的时候，数据变成了十一条
         - 这种情况叫幻读，每次查询的结果不一致

   2. 事务的概念

      | 隔离级别             | 名称     | 存在问题               |
      | -------------------- | -------- | ---------------------- |
      | read uncommit (RU)   | 读未提交 | 脏读、不可重复读、幻读 |
      | read commit (RC)     | 读已提交 | 不可重复读、幻读       |
      | repeatable read (RR) | 可重复读 | 幻读                   |
      | serializable         | 串行化   |                        |

      1. MySQL默认隔离级别
         - 默认是RR，可重复读
         - InnoDB的可重复读是可以避免幻读的
         - 修改隔离级别： SET [GLOBAL | SESSION] TRANSACTION ISOLATION LEVEL level;
         - Spring中设置事务隔离级别： @Transactional（isolation=Isolation.Default)

   3. MVCC机制:

      1. MVCC机制是什么?
         - 多版本并发控制机制
         - 