# 执行计划

## 概述

1. ### 什么是执行计划？用途是什么？

   1. 每次提交一个SQL给MySQL，他内核的查询优化器，都会针对这个sql语句生成一个执行计划
   2. 这个执行计划代表了怎么插叙各表？用哪些索引？如何做排序和分页等

2. ### 执行计划包含了哪些内容？

   1. const：在执行计划中，表达的是性能超高的常量级的查询。如根据primary key进行查询，或者是根据二级唯一索引进行查询，由于这种索引具有唯一性，可以通过二分查找法定位到具体数据，所以是最快的

   2. ref ： 普通的二级索引查找方式

      如果是联合索引，仅有包含联合索引的左前缀查询，才是这种方法

   3. ref_or_null： 对二级索引进行了非空约束的查找类型

   4. range： 有范围查询时，会走这个方式进行查询

   5. index： 如有index（xx1，xx2，xx3），然后查询语句为 where xx2='a'也是会走索引的，会根据index这个索引找到索引页，遍历所有索引页然后返回

   6. all： 全表扫描，扫描叶子结点的所有数据

3. ### 什么时候会用到执行计划？

   - 不可能索引都能兼容所有查询，如key（x1） 在查询为where x1 = 'xx' and x2 = 'xx'，只建立一个索引x1去查找第一波数据的id，然后再回表筛选出所有数据，再过滤出满足x2的数据也是可以的
   - 有两个单独索引，key(x1) key(x2)，当查询语句为where x1= 'xxx' and x2 = 'xxx'的时候，优化器会选择分别查找x1='xxx'和x2='xxx'，然后取交集，再去聚簇索引中回表去查询数据即可。同理or语法则会取并集

## 表关联的查询

1. ### 多表关联的查询语句如何执行？

   1. 执行顺序：如查询语句为 select * from t1 , t2 where t1.x1 = 'xxx' and t2.x2 = 'xxx' and t1.x3 = t2.x3
      1. 首先会根据t1.x1来筛选出t1表中的数据，筛选条件可以是const、ref、index或all等
      2. 然后根据t2.x2='xxx'去筛选出t2表中的数据
      3. 再根据t1表中的x3的值去与t2表中的x3的值去匹配
      4. 先查出数据的表t1表为驱动表。根据t1表过滤出来这波数据查的表叫被驱动表

   2. 内连接查询

      inner join： 要求两表数据必须是能完全关联上，才返回

   3. 外连接

      outer join: 又分为左外链接和右外链接

      - 左外连接:  左侧表中的某条数据,即使右表没有找到与之匹配的数据,也返回
      - 右外连接: 右侧表中的某条数据,即使左表未找到与之匹配的数据,也返回

   4. 多表关联的原理

      1. 先在驱动表中根据where条件取出一波数据
      2. 接着循环取出的这波数据，用每条数据都去on和where中去被驱动表里查询
      3. 如果有三张表，则拿到前两张表匹配的数据，再循环去第二张被驱动表中查询

## 执行计划成本

1. ### 什么是执行计划成本？如何计算

   执行成本为MySQL的执行计量单位，根据成本来计算如何制定执行计划。一般执行计划成本分为两块

   - 首先是那些数据在磁盘中，需不需要把数据页从磁盘中读取出来？这里每次将数据页读取到内存中的IO成本，读一页的IO成本为1.0
   - 拿到这些数据页后，是否要经过运算处理？比如验证是否符合搜索条件？是否给数据页排列分组？这类成本属CPU消耗成本。读取和检测一条数据的成本为0.2

2. ### 成本计算步骤方法

   select * from table where x1='xx' and x2 = 'yy'    

   索引为 key(x1)  和 key(x2)

   - 先会看上述能用到哪几个索引，此时发现x1和x2索引都是能用到，既是possible key
   - 接着会计算全表扫描的成本，根据磁盘IO把叶子结点一页页的加载到内存中，判断是否符合搜索条件

3. 全表扫描的成本计算

   - 可先拿到表统计信息：  show table status like ‘表名’，可拿到rows（总表行数）和data length（表数据量大小，除1024即多少k）
   - 每个页16k ， data length 除以16即有多少个数据页，即可以计算全表扫描加载数据页这块的成本
   - 有多少行，则可以计算行过滤的成本

4. 索引的计算成本

   1. 同时一般只能使用一个索引，所以对于不同索引的成本需要分别计算
   2. 在二级索引中，查找一波数据的IO成本，一般涉及到查询条件和查询范围
   3. 一般认为一个范围即等同一数据页，故应为 （1 *1.0） 或 （n *1.0）为个位数
   4. 根据条件筛选，算法： 条数*0.2 + 微调值（大概是20左右）
   5. 拿到id去回表进行查询，每个数据页是1.0 ， 故这块算法为： 行条数*1 +微调值

5. 多表关联的成本计算

   1. 选择一驱动表，从表里筛选出一波符合条件的数据，x2=xxx，x3=yyy
   2. 如若此时x2和x3都有索引
   3. 会分别计算x2和x3的不同索引的成本
   4. 然后筛选出t1表的最佳访问方式，用最低成本将符合条件数据取出来
   5. 接着根据这波数据区t2表里查询数据
   6. 估算t2表的全表扫描以及不同索引之间的成本

## 执行计划优化

1. ### 为什么要进行优化？

   MySQL觉得你写的SQL不够好，执行效率太低

2. MySQL会如何进行优化？

   1. 无关紧要的内容删除掉。如无关紧要的括号

   2. 将恒定的常量改为变量： 如i=5 and j=i 优化为 i=5 and j=5  ，即常量替换

   3. 多表关联时，将值提前查出来

      - 如 select * from t1 join t2 on t1.x1 = t2.x1 and t1.id = 1

      - 即会先执行  select * from t1 where t1.id = 1 查出x2的值

      - 将x2的值代入到t2表中去查询t2表的值，即成了

        select t1.所有常量值 ， t2.* from t1 join t2 on t2.x1 = 上面x2的值

   4. 子查询优化和执行

      1. 最简单子查询  

         select * from t1 where id = (select x1 from t2 where id = 'xxx')

         - 上述查询会先执行子查询，拿到查询结果后，取出x1的值
         - 再根据x1的值代入到t1表中

      2. 子查询中有外表的条件

         select * from t1 where t1 = (select x1 from t2 where t1.x2 = t2.x2)

         - 这种情况下，t2表的值依赖于t1表，效率很低下
         - 首先遍历t1表的数据，对每一条数据都取出x2的值，循环放到子查询中去执行
         - 找出t2表中的x1字段的值，再放到外层去判断，是否符合跟t1表的x1字段匹配

      3. 外表查询为in的情况

   