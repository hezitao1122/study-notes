# 分布式缓存

1. ## 缓存定义

   1. #### 缓存是如何实现高性能的?

      第一次查询的时候从数据库查询数据,然后放入缓存中,第二次直接从缓存中取

   2. #### 用了缓存的不良后果

      1. 缓存与数据库双写不一致
      2. 缓存雪崩
      3. 缓存穿透
      4. 缓存并发竞争

2. ## Redis基础知识

   1. ### Redis和Memcache的区别?

      1. Redis的数据类型比memcache多
      2. 内存效率: memcache比redis高效
      3. 性能: Redis单线程，Memcache多线程，存储大数据时，Memcache优
      4. 集群模式： memcache原生不支持搭建集群，Redis原生支持搭建集群

   2. ### Redis线程模型:

      ![](.\imgs\redis线程模型.png)

      1. redis启动的时候会发送请求到Redis;
      2. redis申请建立连接,基于Serversocket来建议socket连接
      3. 此时redis内部会产生一个AE_READABLE事件
      4. IO多路复用程序会将监听Serversocket产生的事件压入到一个队列中去
      5. 文件事件处理器会从队列中按顺序取出事件,并找到相应的处理器
      6. 连接应答处理器拿到AE_READABLE事件之后,与客户端建立一个socket连接,将socket-1的AE_READABLE事件跟命令请求处理器关联
      7. 当客户端发送命令之后,socket-1将产生一个AE_WRITEABLE事件,由于AE_READABLE事件已经与命令请求处理器关联,所以文件事件分派器会将其分派给命令请求处理器
      8. 命令请求处理器在自己内存中完成操作
      9. 操作完成后,命令请求处理器将socket-1的AE_WRITABLE事件与命令回复处理器关联
      10. 如果此时客户端准备好了接收返回结果,那么Redis中的socket-1会产生一个AE_WRITABLE事件,同样压入队列,事件分派器找到相关联的命令回复处理器
      11. 由命令回复处理器返回客户端一个结果,如OK

   3. ### 为什么单线程效率也高?

      1. 纯内存操作
      2. 核心是非阻塞的IO多路复用程序
         1. IO多路复用程序是非阻塞的,只负责监听锁产生的事件,并将其压入队列
         2. 故可以监听上百个客户端
         3. 事件处理器由于基于纯内存,所以效率高
      3. 单线程反而避免了多线程的频繁上下文切换

   4. ### Redis拥有哪些数据类型?

      1. string
      2. hash - 类似与Java中的Map
      3. List - 有序队列,可以缓存一些List,如文章评论.也可以支持分页,从某个元素读,读多少个
      4. Set - 无序队列,可以自动去重
      5. SortSet - 可以去重,也可以自动排序

   5. ### Redis的过期策略

      1. #### 惰性删除

         - 在进行Get或Set操作的时候,会先检查key是否过期
         - 若过期,则删除key,然后执行相关操作

      2. #### 定期删除

         - 遍历所有库(database)
         - 检查当前库的指定key数量(默认是每个库检查20个)
           - 如果当前库没有一个key设置了过期时间,直接执行下一个库遍历
           - 随机获取一个设置了过期时间的key,检查该key是否过期,过期则删除key
           - 判断定期操作是否已经达到了指定时间(默认为1s),达到了则退出

      3. #### RDB对过期key的处理

         1. 从内存持久化到RDB文件
            - 持久化key之前,会检查是否过期,过期的key不进入RDB文件
         2. 从RDB文件中恢复
            - 数据载入数据库之前,会对key进行过期检查,如果过期,不导入库

      4. #### AOF对过期key处理

         1. 从内存中持久化到AOF文件
            1. 当key过期后,还没有被删除,此时进行执行持久化操作,该key是不会被写入AOF的,因为没有发生修改指令
            2. 当key过期后,在发生删除时,程序会向AOF文件追加一条del命令(将来恢复数据的时候这条数据也会被删除)
         2. AOF写入到库
            1. 会先判断key是否过期,过期则不写入

      5. #### 惰性删除+长期key导致内存满了会怎样?

         ​    会走Redis的内存淘汰策略,有以下几种机制:

         1. noeviction : 不删除策略,内存不足时,写入就报错
         2. allkeys-lru : 删除最近最少使用的key , 最常用
         3. allkeys-random : 所有key中随机删除一些key
         4. volatile-random : 设置了过期时间的,随机删除一些key
         5. volatile-ttl : 设置了过期时间的,优先删除剩余时间短的key
         6. volatile-lru : 设置了过期时间的,最少使用的

3. ## Redis集群知识

   1. ### 单机版Redis如何能支持10万+的QPS?

      1. #### 主从架构

![](..\imgs\主从架构.png)
      2. master-slave的replication复制,master采用异步复制到slave,2.8版本之后slave会主动周期性地确认自己每次复制的数据量

      3. slave复制的时候不会影响到master工作

      4. slave复制的时候不会block数据,会用旧的数据暂时提供服务,完成同步后删除旧数据,加载新数据.重新加载的时候会加锁

      5. slave可以大量用于横向扩容,做读写分离后,在数据量不大的情况可以达到十万级QPS

   2. #### 主从架构的持久化

      1. master必须开启持久化,AOF和RDB都有必要
      2. 热备的话一般从master备份,如果master不进行持久化,master宕机,然后还未选举出来,master又启动了,就会导致数据全量丢失

   3. #### 主从架构的复制原理

      <img src=".\imgs\主从复制.png" style="zoom:50%;" />
![](..\imgs\主从复制.png)
      1. 数据量小的时候,直接从master内存发送至slave内存中,走socket通信
      2. 数据量大的时候,如上图所示:
         1. master会在本地磁盘生成一个RDB快照文件
         2. master将RDB文件发送至slave的机器,并存储在本地
         3. master在写RDB的文件的时候,会将近期写入的数据缓存在内存中
         4. RDB文件传输完成后slave会将其加载进内存
         5. 同时master会将生成的内存信息通过socket发送至slave
         6. RDB文件有断点续传功能,能记录上次读取到的offset进行传输
      3. 数据同步的核心
         1. Master和slave都会维护一个offset,对比即可知道数据不一致的量
         2. backlog日志用于全量复制时的增量日志
         3. master run id ，slave一旦发现自己连接的run id变了，即会做一次全量复制

   4. #### 高可用性

      1. ##### Sentinel下怎样做到高可用性？

         1. ##### 主要能做到两点

            - 集群监控： 监控所有节点
            - 故障转义：可以通过Sentinel进行选举
            - 分布式选举: 需要大多数Sentinel同意

         2. ##### Sentinel高可用原理:

            1. Sentinel至少需要三个实例,保证其健壮性
            2. Sentinel不会保证数据不丢失,只保证集群的高可用性

         3. ##### 导致数据丢失的情况

            1. ###### 异步复制导致的数据丢失

               - 因:Master写成功给客户端返回后,在未同步至slave时,Master宕机了,Slave选举成为了新的Master

            2. ###### 集群脑裂导致的数据丢失

               <img src=".\imgs\集群脑裂.png" style="zoom:50%;" />

               - 因: 集群之间网络分区导致节点间无法进行正常通信,故无法进行数据同步

            3. ##### 解决: 设置两参数

               - min-slave-to-writer=1  至少要求有一个slave数据同步才返回成功
               - min-slave-max-log=10 同步的延迟不能低于10s

         4. #### Sentinel的底层原理:

            1. ##### Sdown和Odown

               - Sdown - 主观宕机，即一个哨兵觉得Master宕机了，就是主观宕机
               - Odown - 客观宕机，如果quorum数量的哨兵觉得Master宕机了，就是客观宕机

            2. ##### 哨兵和Slave集群的自动发现机制

               1. 哨兵的相互发现是通过redis的pub/sub模式进行实现的，每个哨兵都会往__sentinel__:hello这个channel里发送一个消息，这时候所有其他哨兵都可以消费到这个消息，并感知到其他的哨兵的存在
               2. 每隔两秒钟，每个哨兵都会往自己监控的某个master+slaves对应的__sentinel__:hello channel里发送一个消息，内容是自己的host、ip和runid还有对这个master的监控配置
               3. 每个哨兵也会去监听自己监控的每个master+slaves对应的__sentinel__:hello channel，然后去感知到同样在监听这个master+slaves的其他哨兵的存在
               4. 每个哨兵还会跟其他哨兵交换对master的监控配置，互相进行监控配置的同步

            3. ##### Slave的配置自动纠正

               - 即选举机制，如Slave连接到了一个错误的Master上，那么哨兵会将其配置修改过来

            4. ##### Slave的选举机制：

               （此时假设一个Master宕机了，哨兵需要进行准备切换的动作）选举算法为

               1. 跟Master断开连接的时间 down-after-milliseconds
               2. 首先配置的slave优先级，优先级越小越优先
               3. 在2相同的情况下，哪个Slave的offset越靠后
               4. 如果3相同，则选举runid小的
               5. 如果一个slave跟master断开连接已经超过了down-after-milliseconds的10倍，外加master宕机的时长，那么slave就被认为不适合选举为master
               
            5. ##### Redis的持久化

               1. ###### RDB:

                  - 对Redis中的数据进行周期性的持久化

                  ![](..\imgs\RDB线程同步.jpg)

               2. ###### AOF持久化:
                    ![](..\imgs\AOF数据同步.png)

                  - 客户端每往Redis中写入一条数据
                  - Redis会将新写入的数据同步到系统缓存（os cache）中
                  - 系统缓存(os cache)每隔一段时间会进行一次刷盘，将数据写入AOF文件（默认是1s）
                  - Redis会通过rewrite机制控制AOF大小，如果过大会根据内存数据重新进行生成

               3. ##### 优先级

                  如果同时开启了AOF和RDB持久化，则会优先使用AOF进行数据恢复

               4. ##### 优缺点：

                  1. ###### RDB：
                     
                     1. 优点：
                        - 适合做冷备份（Redis控制固定时长，AOF冷备还需自己写脚本）
                        - RDB对数据进行持久化的时候，是异步的，影响很小
                        - 相对于AOF，数据恢复起来更快
                        - 适合做冷备份
                     2. 缺点
                        - 丢失数据会比较多（备份间隔较长）
                        - 不适合做第一优先的恢复方案
                  2. ###### AOF
                     
                     1. 优点：
                        - AOF追加基于秒级，数据丢失较少，同步为异步化操作
                        - 以append-only方式在文件地址末尾进行追加,无寻址开销,写入性能高,不易破损,并且如若文件尾部破损,也较为容易修复
                        - 新、老文件交替时，对读写性能无影响
                        - 记录的为伪指令，可写性高，可认为修改
                     2. 缺点：
                        - 数据量相同的情况下，AOF文件比RDB文件要大
                        - 开启之后，支持写的QPS会降低
                        - 每次rewrite是基于当前内存数据，而不是旧指令
                        - 冷备份不方便，需要写脚本

         5. ### Redis cluster原理

            1. #### 使用场景:

               1. 可支持N个redis master ，每个Master都支持多个Slave节点
               2. 可做高可用读写分离
               3. 主要针对海量数据+高并发场景

            2. #### Redis Cluster的算法

               1. ##### hash算法
                    ![](..\imgs\redis-cluster-hash算法.jpg)
                  <img src=".\imgs\redis-cluster-hash算法.jpg" style="zoom:50%;" />
                  - 对key进行取膜,如求余,求与等,然后进行数据路由
                  - 存在问题: 某一个master宕机后,需要对一个key重新取模运算,大部分数据重新取模后需要重新定位,导致缓存失效.
               2. ##### 一致性hash算法
                  
                  <img src="..\imgs\一致性hash算法.png" style="zoom:33%;" />\
                    ![](..\imgs\一致性hash算法.png)

                  1. 算法:
                     1. 有一颗key过来后，计算hash值
                     2. 用计算出来的hash值在圆环对应的各个点
                     3. 计算出在哪个点后，顺时针到一个Node
                  2. 特点：
                     1. 仅影响宕机Node之前的节点数据
                  3. 缺点：
                     1. 缓存热点问题，可能同一个区的数据访问频率过多
                  4. 解决：
                     1. 引入如上虚拟节点，使得Node-2到虚拟环的数据打到其他节点(如Node-2或Node-1)
               
               3. #### hash slot算法
               
                  1. 算法:
                     1. 对每个key计算CRC16值，并对16384取模
                     2. 产生大概16384个slot，并讲slot均匀的分散给各个节点
                     3. 某个节点宕机，最多损失1/N的数据
                     4. 同时会将宕机的master的slot平均分配给其他几台master节点
               
            3. #### 节点间通信

               1. ##### 集群的元数据存储

                  1. ###### 集中式存储：

                     <img src="..\imgs\Redis-cluster集中存储.png" style="zoom: 50%;" />、
                     ![](..\imgs\Redis-cluster集中存储.png)   
                     - 时效性高
                     - 变更快
                  2. ###### gossip协议（分布式存储）：

                     <img src="..\imgs\gossip协议.png" style="zoom:50%;" />，
                     ![](..\imgs\gossip协议png)
                     - 所有节点都存储元数据
                     - 如果一方有变更，则推送给其他节点
                     - 缺点： 推送操作有一定的延时

                  3. ###### smart jedis：

                     1. 本地维护一份hash slot的映射表,直接走本地缓存
                     2. 原理:
                        1. Jedis cluster在初始化时,随机选一个Node初始化hash slot
                        2. 同时在本地建立一个jedis pool连接池
                        3. 如果node发挥remove,则更新hash slot映射表

            4. #### 高可用和故障转移的原理

               1. ##### pfail和fail
                  
                  1. pfail -> 主观宕机 : 一个节点认为一个master宕机了 , 类似哨兵sdown
                  2. fail -> 客观宕机: 多节点(n/2 +1)节点认为一个节点宕机了 类似哨兵odown
               2. ##### 原理:
                  
                  1. 各个节点会通过相互发送消息的方式来交换集群节点的状态信息
                  2. 当一个主节点向另一个主节点发送消息,切cluster-node-time一直未返回pong，则认为此节点为pfail
                  3. 发送给其他节点pong信息，如果大部分节点都认为pfail，则将此节点升级为fail
               3. ##### 故障转移
                  
                  1. 当一个slave节点发现自己所在的master宕机后，从节点开始故障转移
                     1. 一个slave节点会被选中
                     2. 被选中的slave会执行SLAVEOF no one命令，成为新的主节点
                     3. 新的master会下线已指向旧master的槽，并将这些槽指派给自己
                     4. 新的master节点像其他节点广播一条pong消息，通知master已变更

         6. ### 缓存雪崩和缓存穿透

            1. #### 缓存雪崩
               
               1. ##### 原理：
                  
                  1. 缓存服务器宕机，导致用户请求所有都打到了数据库
                  2. 数据库因为请求量过大也宕机
                  3. 数据库重启之后又宕机
               2. #### 解决：
                  
                  1. ##### 事前
                     
                     1. 保证集群的高可用性，引用Ehcache缓存少部分数据
                     2. 主从机制，避免MySQL被请求打死
                  2. ##### 事中：
                     
                     1. 本地缓存
                     2. hystrix限流—+熔断，避免请求打到MySQL
                     3. 原理：
                        - 用户发送请求
                        - 收到请求后先查询Ehcache，没有查到的画查询Redis
                        - 都没有查到则查询数据库，并写入缓存
                        - 好处： 
                          - 有限流熔断主件可以保证MySQL不被打死
                          - 有部分请求可以返回（Ehcache有数据）和熔断返回，代表服务没宕机
                  3. ##### 事后：
                     
                     1. Redis进行持久化
                     2. 快速恢复数据
            2. #### 缓存穿透
               
               1. 原理：
                  1. 大部分请求，请求缓存都不存在，然后请求到数据库中
                  2. 请求打到数据库中也不存在
                  3. 无法写入数据到缓存中，故每次请求都请求数据库
               2. 解决
                  1. 每次将不存在的数据也写入缓存
                  2. 对key的合法性进行过滤

         7. ### 缓存与数据双写不一致：

            即缓存中的数据与数据库中的数据不一致

            1. #### 最初级：
               
               1. ##### 解决：
                  
                  1. 写入的时候先写数据库，再写缓存
                  2. 删除的时候，先删缓存再删数据库
               2. ##### 问题：
                  
                  1. 删除缓存时，后进行修改
                  2. 如果此时，又有一个线程去读，没有读取到，然后就去数据库里去查
                  3. 此时第一个线程修改完后写入缓存中
                  4. 然后读请求读取完成后，又写入缓存之中
                  5. 所以便产生了缓存不一致现象
               
            2. #### 高并发下，读写不一致

               存在最初级的问题

               ​	<img src=".\imgs\高并发下读写不一致问题.png" style="zoom:38%;" />
                    ![](..\imgs\高并发下读写不一致问题.png)
               1. ##### 原理

                  1. 对同一商品的读、写请求操作，进入到同一个队列之中，进行串行化操作
                  2. 相同的读操作可做超时处理

               2. ##### 缓存为空问题

                  1. 数据库不存在 -> 看内存中是否存在，没则直接返回
                  2. 如果有（即前面读操作队列中有此读操作），则等待一会

               3. ##### 问题：

                  1. 可能挤压多个商品的读写请求，会导致读长时间阻塞
                  2. 解决：多加机器，使得每个内存队列的请求减少

               4. ##### 应该注意：

                  1. 每个读请求不能hang太久的读时间，且得计算好每台读机器同时hang住的读请求不能太多
                  2. 如果读和写请求路由到不同的机器：
                     - 自己写同一商品的读写hash路由
                     - 借助Nginx和请求参数路由到同一台机器
                  3. 热点商品问题，导致某台机器请求过多
                     - 仅有更新的时候才会有读写请求打到服务器，所以不要紧
                  4. 如果读和写不要求严格不一致，则不建议来串行化处理，会导致吞吐量不一致

         8. #### 什么是Redis的并发竞争问题？ 怎么解决？

            1. ##### 并发竞争问题：

               1. 多客户端同时写一个key，从而导致顺序的不一致性
               2. 如 同时写入 k1 v1 -> k1 v2 -> k1 v3 结果则成  k1 v1 -> k1 v3 -> k1 v2

            2. ##### 解决

               1. Redis使用zk的分布式锁,写的时候根据时间戳进行先后顺序的判断

            




