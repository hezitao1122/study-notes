# 线程模型和网络通信

## Redis的线程模型

1. Redis的单线程为什么那么快？
   1. 主要是指Redis的网络IO和键值读写的时候，是由一个线程进行操作的。
   2. 这也是redis对外提供键值存储的主要流程。
   3. 但如持久化、异步删除、集群同步等操作，则是由额外线程提供操作。
   
2. 为什么只用单线程?

   1. 多线程的开销

      - 如果没设计好线程模型，期望效果和实际效果如下图所示

        ![](..\imgs\Redis单线程和多线程的期待效果和实际效果.jpg)

      - 即增加线程的时候，前期效果明显，后期增加线程性能不变甚至有性能下降

      - 瓶颈在于： 多线程的资源共享，如多线程需修改同一数据的时候，需要额外机制进行保证。即会带来额外开销，即共享资源的并发问题

      - 简单的加互斥锁，也会将操作编程串行化

   2. 单线程为什么操作会快？

      - 大部分操作在内存中
      - 具有高效的数据结构
      - 多路IO复用的网络模型

## Redis的网络通信

1. Redis的基本网络操作

   ![](..\imgs\Redis有哪些基本操作.jpg)

   1. 即基本数据操作都在一个线程内完成
   2. 网络IO有潜在的阻塞点，分别是accept操作和recv操作

2. 非阻塞模式

   socket非阻塞模式主要体现在三个关键函数的调用上

   - socket不同操作调用后会返回不同套接字的类型

   - socket（） 方法会返回主动套接字

   - listen（）方法将主动套接字转化为FD监听套接字

   - accept（） 方法接收到达的客户端连接，并返回已连接的套接字

   - Redis调用accept（）方法时，一直未有连接请求到达时，Redis线程可返回去处理其他操作。

     | 方法       | 名称         | 是否阻塞 | 效果                |
     | ---------- | ------------ | -------- | ------------------- |
     | socket（） | 主动套接字   |          |                     |
     | listen（） | 监听套接字   | 可设置   | accept（）非阻塞    |
     | accept（） | 已连接套接字 | 可设置   | send()/recv()非阻塞 |

3. 基于多路复用的高性能IO模型

   ![](..\imgs\Redis基于多路复用的高性能IO模型.jpg)

   1. select/epoll机制: 一个线程可以同时处理多个IO流，该机制允许内核中同时存在多个监听套接字和已连接套接字

   2. 调用流程

      - FD代表多个套接字，每个线程请求到Redis就会产生一个套接字，Redis网络框架通过epoll机制让内核监听套接字
      - 此时Redis线程不会阻塞某一个特定监听，或已连接的套接字上
      - select/epoll机制提供了基于事件的回调机制，基于不同事件回调相对应的函数
      - select/epoll机制一旦监听到FD套接字中有请求产生，就会触发调用相应的事件
      - 这些事件会放到一个相应的事件处理器队列之中。
      - Redis线程会不断的对这些事件进行处理

   3. 潜在的性能和瓶颈

      任意一个Redis请求在server中一旦发生耗时操作，都会影响整个server的性能，包括：

      - bigkey操作，写入一个bigkey（涉及分配内存和网络IO）和删除一个bigkey（涉及回收内存和网络IO）
      - 复杂度较高的命令： SORT / SUNION / ZUINONSTORE 或O(N)时间复杂度的命令(数组和链表遍历时候N比较大)，如lrange key 0 -1一次查询全量数据
      - 大量key集中过期，处理批量查询请求的时候，耗时都在删除key的过程中
      - 淘汰策略（LRU）： 当内存达到上限后，每次写入一些数据，都要批量淘汰一批key
      - AOF持久化刷盘开启了aways机制： 每次写入都把操作刷入磁盘中
      - 主从同步生成RDB： 虽然采用fork紫禁城的方式生成快照，但是fork的时候也是会造成线程阻塞的。它要将内存进行拷贝

   4. 并发非常大的时候，单线程读写客户端IO数据存在性能瓶颈，只能单线程进行读写，无法利用多核CPU

   5. 解决：

      - 针对bigkey，一方面需要开发者去规避，一方面4.0版本退出了lazy-free操作，把bigkey放到异步线程中去执行
      - Redis6.0版本提供了多线程。只针对客户端读写是并行操作的，每个命令真正操作内存还是串行化执行的。

