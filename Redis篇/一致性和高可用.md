# 一致性和高可用

## 主从库的数据一致性

1. ### 为什么要有数据一致性？

   缓解写请求压力，也可当redis的数据备份

2. ### 解决了什么问题?

   1. 服务尽量少中断: 增加副本冗余的数量
   2. 读写分离

3. ### 主从库第一次数据同步执行了哪些过程?

   ![](..\imgs\Redis主从库第一次进行数据同步的过程.jpg)

   1. 第一阶段:
      1. 从库与主库建立连接，并告知主库即将进行数据同步
      2. 从库发送给主库psync命令，包含runID（此时还未获取到主库的runID）和复制的offset进度（默认是-1）
         - runID为每个redis启动的时候，随机生成的ID，第一次为？号
         - offset表示复制进度，第一次为-1
   2. 主库将所有数据转储为RDB文件，发送给从库，从库在本地进行加载
   3. 主库把第二阶段（在生成和传输RDB文件）期间产生的日志写入到内存，再发送给从库

4. ### 主-从-从模式

   ![](..\imgs\Redis主从从模式.jpg)

   1. 解决问题： 主库复制的时候传输开销
   2. 将生成RDB文件的开销和传入RDB文件的压力分散到从库中
   3. 部署的时候，可手动选择一个从库，用于级联其他从库，然后自动选择一些从库（如1/3的从库)在这些从库上执行命令，让他们与所选从库建立主从关系，replicaof所选从库即 ip 6379
   4. 后续会维护一网络连接，长连接进行数据同步

5. 主从库之间的网络连接

   1. 存在的风险：
      1. 网络断连
      2. 网络阻塞
   2. 网络断连后会执行哪些操作?
      1. 在redis版本2.8之前，如果发生断连，主库会和从库发生一次全量复制
      2. 在redis版本2.8之后，主库会采用增量复制的方式继续同步数据
         - 增量复制时，有一个repl_backlog_buffer缓存区
         - 主从库的网络连接断开之后，主库会把断开连接期间的写命令，写入到replication buffer这个区域
         - 同时写写入到repl_backlog_buffer缓冲区
         - repl_backlog_buffer是一个环形缓冲区，主库会读取自己写入的位置，从库会读取自己读取的位置。分别是master_repl_offset和slave_repl_offset
         - 主库仅需讲两个offset之间的命令同步给从库即可
      3. replication_backlog_buffer是一个环形缓冲区，缓冲区满后会继续写入数据，会覆盖之前的写入命令
      4. repl_backlog_size大小： 公式为 大小=主库写入速度*操作数据的大小 - 朱从库之间网络传输命令速度*操作大小，不过一般会取此值的两倍
   3. 总结：
      1. 同步原理：
         1. 全量复制： 耗时。故一个redis实例不应太大，几个G的数据即可。也可用主-从-从架构
         2. 基于长连接的命令传输： 正常连接的复制。网络断连的时候，使用增量复制
         3. 增量复制：需调整环形缓冲区repl_backlog_size大小，如覆盖了则会进行全量复制
      2. 为什么用RDB日志，而不是用AOF日志？
         1. RDB是二进制文件日志，文件较小，传输速度快，恢复速度也快
         2. AOF日志会影响redis的吞吐量
      3. 应该是主库有从库存在，都会有一个repl_backlog_buffer缓冲区，从库断连后发送psync $mastered_runid $offset进行数据同步
      4. replication buffer : redis与从库或客户端通信，都会分配一个client buffer，redis先把数据写入到这块buffer中，然后把offset中的数据发送到client socket中，通过网络发送出去，主从同步的通信缓冲区通常称为 replication buffer
      5. client-output-buffer设置上述的大小，如主从复制异常慢会导致此块内存空间过大，而发生OOM



