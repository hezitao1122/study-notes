# Redis的持久化

## 概述

1. Redis持久化的方法：
   - append only file： AOF日志
   - RDB快照

## AOF日志

1. ### AOF的日志实现

   ![](..\imgs\Redis的AOF操作过程.jpg)

   1. AOF日志为写后日志，即先执行命令再执行写日志
   2. 记录了Redis收到的每一行命令，以文本形式进行保存
   3. 为什么要先执行写入再记录日志？
      - 记录日志的时候不做语法检查
      - 不会阻塞当前写操作
      - 风险： 
        - 执行成功后宕机会有数据丢失的风险
        - 可能会给下一个操作带来阻塞的风险
        - AOF日志在主线程执行，如若写入过慢，会给后续操作无法执行
   
2. ### 三种写入策略

   1. Always： 同步写回，每个写完数据，立马将日志写回磁盘，会影响主线程的性能
   2. Everysec： 每秒写回。宕机可能会丢失一秒内的数据
   3. No ： 由操作系统决定刷盘策略。未刷盘的数据会丢失，性能最高

3. ### AOF文件过大会怎么办？

   1. AOF文件过大存在的问题：
      - 操作系统无法保存过大的文件
      - 文件过大之后追加，会导致写入效率低下
      - 故障恢复时，需要一个个命令逐步执行，将非常缓慢
   2. 重写日志有多变一的功能： 旧日志多条命令，在重写新日志后会变成一条数据，节省空间
   3. 重写根据当前数据最新状态生成写命令，节省空间

4. ### 重写会不会阻塞主线程？

   1. 重写由后台子进程bgrewriteaof来完成

   2. 一个拷贝，两处日志：

      - 一个拷贝： 重写时，主线程fork出后台bgrewriteaof子进程，并把主线程的内存拷贝过去，bgwriteaof进程进行写入

      - 两处日志： 有写操作的话，会同时写入到两个AOF日志的缓冲区

        ![](..\imgs\Redis的AOF过程.jpg)

   ## RDB日志

   1. ### 解决问题

      1. AOF日志打的时候，恢复数据较慢
      2. AOF执行数据恢复的时候，需要逐条进行执行

   2. ### 对哪些数据做快照？

      1. 为保证redis的可靠性，记录的为全量快照
      2. 提供了两种命令生成快照：
         - save：主线程中执行生成快照文件，会阻塞主线程
         - bgsave： fork一个子进程，专门用于RDB文件的写入，默认模式

   3. 做快照的时候还能被修改数据吗？

      - 不能为了生成快照而暂停所有写操作
      - redis会借助操作系统提供的写时复制技术（copy-on-writer)在执行快照时，正常处理写请求
      - 子进程可共享主线程的所有内存数据
      - 如果主线程对这些操作都是读，相互不影响
      - 如果主线程要对这些数据进行修改，那么操作系统会复制该数据，生成一个副本

   4. 多久会做一次快照？快照的开销？

      1. 频繁快照两方面消耗：
         - 会给磁盘带来压力，太频繁会导致多个快照竞争磁盘IO资源
         - fork本身是会阻塞主线程的，且主线程内存越大，阻塞的时间越长

   5. 有什么好办法防止频繁全量快照？

      - 在做完一次全量快照后，每隔一段时间做增量快照
      - 需记录哪些数据被修改，会有额外的内存开销

   6. 混合使用RDB和AOF快照：

      - 避免频繁fork对主线程的印象
      - AOF日志也只用记录两个RDB快照的间隔日志

   7. 建议：

      1. 数据不能丢失时，内存快照和AOF快照混合使用
      2. 如可允许分钟级数量丢失，可只使用RDB快照
      3. 如只使用AOF快照，优先使用everysec配置

   