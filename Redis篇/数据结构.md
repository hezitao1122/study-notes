# 数据结构与算法

## 数据结构

1. ### string数据类型的value

   1. 除了记录实际数据，还需额外内存记录数据长度、空间使用长度等

   2. 当你保存了64位有符号整数时，string类型会把它保存为一个8字节的long类型的数组，也成为int编码方式

   3. 保存的数据有字符时，使用SDS（simple dynamic string）结构来保存数据，如下图所示

      ![](..\imgs\Redis的SDS结构.jpg)

      - len(4B) 表示buf的实际使用长度
      - alloc(4B) 表示buf的实际分配长度
      - buf("Redis\0") 表示实际的数据，末尾有一个\0代表数据结束

   4. 除了SDS开销，还有一个来自于RedisObject结构的开销，因为Redis的数据类型很多，而且不同的数据类型有些相同元素数据要记录。（例如最后一次被访问时间、被索引次数等）

      ![](..\imgs\Redis的RedisObject结构.jpg)

      1. RedisObject包含了8个字节的元数据，和一个8字节的指针，元数据为int编码

      2. 当保存为long类型的数据时，RedisObject中的指针就是直接赋值为整数数据，不需要额外开销

      3. 当保存的为字符串类型，且字符串长度小于44字节的时候，元数据、指针和SDS结构是一块连续的内存空间，通过embset编码

      4. 当保存的为字符串类型，且大于44字节的时候，采用raw编码

         ![](..\imgs\Redis保存string类型的各种编码.jpg)

   5. hash表的entry结构

      ![](..\imgs\Redis保存hash表的entry结构.jpg)

      1. dictEntry结构
      2. 这里还剩32bi ， 但是key、value和next仅包含24bi，还剩下8bi数据存放在哪？
      3. 原因： jemalloc内存分配器在申请内存的时候，会根据申请的字节N，找一个比N大，但是接近N的32位整数。（如24位->则选择32位)，这样可减少内存的频繁分配

2. 压缩列表： ziplist

   ![](..\imgs\Redis的ziplist结构.jpg)

   1. 每个元素包含以下几个部分：
      - prev_len： 表示当前一个entry的长度，有两种情况
        - 1字节： 当前entry长度小于254字节，即用一个字节表示
        - 5字节： 当前entry长度大于等于255字节，即用5字节来表示长度
      - len表示： 表示自身长度，4字节
      - encoding： 表示编码方式，1字节
      - key（content）： 实际的数据存储
   2. 